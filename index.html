<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>月亮粒子圣诞树 - Single Moon Tree</title>
    <!-- 引入 Google Fonts: Great Vibes (优雅手写体) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%);
            /* 默认字体回退 */
            font-family: 'Arial', sans-serif; 
        }
        canvas {
            display: block;
        }
        #overlay {
            position: absolute;
            top: 85%; 
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            text-align: center;
            pointer-events: none;
            z-index: 10;
            width: 100%;
            
            /* 修改动画：6秒一个循环，无限播放 */
            opacity: 0; 
            animation: textLoop 6s ease-in-out infinite;
        }
        
        @keyframes textLoop {
            0% {
                opacity: 0;
                transform: translate(-50%, -40%); /* 从稍微偏下的位置开始 */
                text-shadow: none;
                color: #333; /* 初始颜色很暗 */
            }
            40% {
                /* 约 2.4秒 变亮过程 */
                opacity: 1;
                transform: translate(-50%, -50%); /* 浮动到中间 */
                color: #fff;
                text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px rgba(135, 206, 235, 0.6), 0 0 30px rgba(135, 206, 235, 0.4);
            }
            60% {
                /* 40%~60% 是保持阶段，约 1.2秒 长亮 */
                opacity: 1;
                transform: translate(-50%, -50%);
                color: #fff;
                text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px rgba(135, 206, 235, 0.6), 0 0 30px rgba(135, 206, 235, 0.4);
            }
            100% {
                /* 慢慢变暗消失 */
                opacity: 0;
                transform: translate(-50%, -60%); /* 继续微向上浮动 */
                text-shadow: none;
                color: #333;
            }
        }

        h1 {
            /* 使用新字体 */
            font-family: 'Great Vibes', cursive;
            font-size: 6vw; /* 稍微调大一点，因为这款字体偏细 */
            margin: 0;
            white-space: nowrap;
            letter-spacing: 2px;
            font-weight: 400; /* 保持字体原有的优雅感，不要太粗 */
        }
        
        /* 移动端适配 */
        @media (max-width: 768px) {
            h1 { font-size: 3.5rem; }
            #overlay { top: 85%; }
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>Merry Christmas to HQ</h1>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let tree; // 单棵树
        let snow = [];

        // 配置参数
        const CONFIG = {
            particleCount: 2000, 
            treeWidth: 300,      
            treeHeight: 500,     
            rotateSpeed: 0.008,  
            perspective: 500
        };

        // 调整画布大小
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            if (width < 600) {
                CONFIG.treeWidth = width * 0.5;
                CONFIG.treeHeight = height * 0.6;
                CONFIG.particleCount = 1200; 
            } else {
                CONFIG.treeWidth = Math.min(400, width * 0.3);
                CONFIG.treeHeight = Math.min(600, height * 0.7);
                CONFIG.particleCount = 2000;
            }
            
            initScene();
        }
        window.addEventListener('resize', resize);

        // 3D 粒子类
        class Particle {
            constructor(treeX, treeY, colorPalette) {
                this.treeX = treeX; 
                this.treeY = treeY; 
                this.colorPalette = colorPalette;
                this.reset();
            }

            reset() {
                this.y = Math.random() * CONFIG.treeHeight; 
                let radius = (CONFIG.treeWidth / 2) * (1 - this.y / CONFIG.treeHeight);
                radius += (Math.random() - 0.5) * 15; 
                
                let angle = Math.random() * Math.PI * 2;
                
                this.x = Math.cos(angle) * radius;
                this.z = Math.sin(angle) * radius;
                
                this.size = Math.random() * 2.5 + 0.5; 
                this.color = this.colorPalette[Math.floor(Math.random() * this.colorPalette.length)];
                this.alpha = Math.random() * 0.5 + 0.5;
                this.sparkleSpeed = Math.random() * 0.05 + 0.01;
                this.phase = Math.random() * Math.PI * 2;
            }

            update(angleOffset) {
                this.phase += this.sparkleSpeed;
                this.currentAlpha = this.alpha * (0.6 + 0.4 * Math.sin(this.phase));

                let cos = Math.cos(angleOffset);
                let sin = Math.sin(angleOffset);
                
                let rx = this.x * cos - this.z * sin;
                let rz = this.x * sin + this.z * cos;

                let scale = CONFIG.perspective / (CONFIG.perspective + rz + 400); 
                
                this.projX = this.treeX + rx * scale;
                this.projY = (this.treeY - this.y) * scale + (height * 0.15); 
                this.projSize = this.size * scale;
                this.projScale = scale; 
            }

            draw() {
                ctx.globalAlpha = this.currentAlpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.projX, this.projY, this.projSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 地面倒影
                ctx.globalAlpha = this.currentAlpha * 0.15;
                let baseGroundY = this.treeY + (height * 0.15); 
                let distFromBase = baseGroundY - this.projY;
                let reflectY = baseGroundY + distFromBase * 0.8; 
                
                ctx.beginPath();
                ctx.arc(this.projX, reflectY, this.projSize * 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 月亮类
        class MoonTopper {
            constructor(x, y, size, color) {
                this.x = x;
                this.y = y;
                this.baseY = y; 
                this.size = size;
                this.color = color;
                this.floatOffset = 0;
            }

            draw(angle) {
                // 上下浮动动画
                this.floatOffset += 0.03;
                let currentY = this.y + Math.sin(this.floatOffset) * 3;

                ctx.save();
                
                // 1. 移动到月亮中心位置
                ctx.translate(this.x, currentY);
                
                // 2. 模拟 3D 旋转 (绕 Y 轴)
                // 使用 cosine 函数来计算水平缩放，这会模拟平面月亮随着树旋转的效果
                let scaleX = Math.cos(angle);
                ctx.scale(scaleX, 1);
                
                // 长亮设置
                ctx.shadowBlur = 40; // 增强光晕
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 1; // 保持不透明

                // --- 绘制月亮形状 (标准的 C 型月牙) ---
                
                // 1. 绘制主体圆 (底色)
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // 2. 切换到“擦除”模式 (Destination-Out)
                ctx.globalCompositeOperation = 'destination-out';
                
                // 3. 绘制遮罩圆 (挖空部分)
                // 向右偏移 (size * 0.4) 以形成左侧月牙
                ctx.beginPath();
                ctx.arc(this.size * 0.4, 0, this.size * 0.9, 0, Math.PI * 2);
                ctx.fill();
                
                // 4. 恢复默认混合模式
                ctx.globalCompositeOperation = 'source-over';
                
                // 5. 补充高亮边缘 (因为挖空后边缘可能没有光晕了，这里手动补一个描边)
                // 注意：由于 scale 存在，描边也会被挤压，这正是我们想要的效果
                ctx.shadowBlur = 15;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                
                // 重新描绘一个月牙路径用于描边 (模拟上述挖空后的形状)
                // 这里简化处理，只描绘一个近似的弧线，或者直接重绘一次剪切流程做描边有点复杂
                // 简单方案：画一个略小的月牙作为高光核心
                
                // 更好的边缘处理：由于 destination-out 擦除了像素，stroke 无法直接沿着“剪切线”描边
                // 但因为我们有强烈的 shadowBlur，视觉上已经发光了，所以这里可以省略 stroke
                // 或者，我们可以画一个很细的白色圆弧来点缀
                
                ctx.restore();
            }
        }

        // 树类
        class Tree {
            constructor(x) {
                this.x = x;
                this.particles = [];
                const palette = ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#FFFFFF', '#E0F2F1', '#FFF9C4'];
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    this.particles.push(new Particle(x, height * 0.7, palette));
                }
                this.angle = 0;
                
                // 初始位置占位，实际位置在 updateAndDraw 中计算
                this.topper = new MoonTopper(x, 0, 35, '#E0F7FA');
            }

            updateAndDraw() {
                this.angle += CONFIG.rotateSpeed;
                
                // --- 关键修改：精准计算树尖位置 ---
                // 使用与粒子相同的透视投影公式
                // 树顶在 3D 空间中的坐标: x=0, z=0 (相对树心), y=CONFIG.treeHeight
                let scaleAtCenter = CONFIG.perspective / (CONFIG.perspective + 400); // z=0 时的缩放比 (rz=0)
                let treeBaseY = height * 0.7; // 树底在 3D 世界的 Y
                let treeTipWorldY = CONFIG.treeHeight;
                
                // 计算屏幕上的 Y 坐标
                // 公式: projY = (treeY - y) * scale + offset
                let screenTipY = (treeBaseY - treeTipWorldY) * scaleAtCenter + (height * 0.15);
                
                // 将月亮位置设置在树尖上方一点点 (减去一点偏移量)
                this.topper.x = this.x;
                this.topper.y = screenTipY - 20; 
                
                this.particles.forEach(p => p.update(this.angle));
                this.particles.sort((a, b) => a.projScale - b.projScale);
                this.particles.forEach(p => p.draw());
                
                // 传入当前角度，让月亮参与旋转
                this.topper.draw(this.angle);
            }
        }

        // 雪花
        class Snow {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * -height;
                this.speed = Math.random() * 1.5 + 0.5;
                this.size = Math.random() * 2;
                this.opacity = Math.random() * 0.5 + 0.1;
            }
            draw() {
                this.y += this.speed;
                if (this.y > height) this.reset();
                ctx.fillStyle = `rgba(255,255,255,${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initScene() {
            tree = new Tree(width / 2);
            snow = [];
            for(let i=0; i<150; i++) snow.push(new Snow());
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            let grad = ctx.createLinearGradient(0, height * 0.65, 0, height);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.4, 'rgba(20, 40, 70, 0.2)'); 
            grad.addColorStop(1, 'rgba(10, 20, 40, 0.5)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, height * 0.65, width, height * 0.35);

            snow.forEach(s => s.draw());
            
            if (tree) tree.updateAndDraw();

            requestAnimationFrame(animate);
        }

        resize();
        animate();
    </script>
</body>
</html>
